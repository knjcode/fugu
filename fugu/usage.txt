Usage: fugu COMMAND [LABEL] [arg...]

Swiss Army knife for Docker.

Commands:
    build        Build an image from a Dockerfile
    run          Run a command in a new container
    exec         Run a command in a running container
    shell        Open a shell in a running container
    destroy      Kil a running container and remove it
    push         Push an image or a repository to the registry
    pull         Pull an image or a repository from the registry
    images       List images (from remote registry)
    show-data    Show aggregated data for label
    show-labels  Show all labels
    help         Show help

Run 'fugu help COMMAND' for more information on a command.


------------------------------------------


Usage: fugu build [LABEL] [OPTIONS] [PATH | URL]

Build a new image from the source code at PATH

Fugu options:
  --dry-run=false           Just print commands
  --image=""                Name of the image
  --path=""                 PATH
  --source=[]               Get data from this source
  --tag-git-branch=false    Tag with current git branch
  --url=""                  URL

Docker options:
  -f, --file=""        Name of the Dockerfile (Default is 'PATH/Dockerfile')
  --force-rm=false     Always remove intermediate containers
  --no-cache=false     Do not use cache when building the image
  --pull=false         Always attempt to pull a newer version of the image
  -q, --quiet=false    Suppress the verbose output generated by the containers
  --rm=true            Remove intermediate containers after a successful build
  -t, --tag=""         Tag for the image (!)

Example source options:
  --source=file://config.yml


------------------------------------------


Usage: fugu run [LABEL] [OPTIONS] [COMMAND] [ARG...]

Run a command in a new container

Fugu options:
  --arg=[]           ARG
  --command=""       COMMAND
  --dry-run=false    Just print commands
  --image=""         Name of the image
  --source=[]        Get data from this source

Docker options:
  -a, --attach=[]            Attach to STDIN, STDOUT or STDERR.
  --add-host=[]              Add a custom host-to-IP mapping (host:ip)
  -c, --cpu-shares=0         CPU shares (relative weight)
  --cap-add=[]               Add Linux capabilities
  --cap-drop=[]              Drop Linux capabilities
  --cidfile=""               Write the container ID to the file
  --cpuset=""                CPUs in which to allow execution (0-3, 0,1)
  -d, --detach=false         Detached mode: run the container in the background and print the new container ID
  --device=[]                Add a host device to the container (e.g. --device=/dev/sdc:/dev/xvdc:rwm)
  --dns=[]                   Set custom DNS servers
  --dns-search=[]            Set custom DNS search domains (Use --dns-search=. if you don't wish to set the search domain)
  -e, --env=[]               Set environment variables
  --entrypoint=""            Overwrite the default ENTRYPOINT of the image
  --env-file=[]              Read in a line delimited file of environment variables
  --expose=[]                Expose a port or a range of ports (e.g. --expose=3300-3310) from the container without publishing it to your host
  -h, --hostname=""          Container host name
  -i, --interactive=false    Keep STDIN open even if not attached
  --ipc=""                   Default is to create a private IPC namespace (POSIX SysV IPC) for the container
                               'container:<name|id>': reuses another container shared memory, semaphores and message queues
                               'host': use the host shared memory,semaphores and message queues inside the container.  Note: the host mode gives the container full access to local shared memory and is therefore considered insecure.
  --link=[]                  Add link to another container in the form of <name|id>:alias
  --log-driver=              Logging driver for container
  --log-opt=[]               Log driver options
  --lxc-conf=[]              (lxc exec-driver only) Add custom lxc options --lxc-conf="lxc.cgroup.cpuset.cpus = 0,1"
  -m, --memory=""            Memory limit (format: <number><optional unit>, where unit = b, k, m or g)
  --mac-address=""           Container MAC address (e.g. 92:d0:c6:0a:29:33)
  --memory-swap=""           Total memory usage (memory + swap), set '-1' to disable swap (format: <number><optional unit>, where unit = b, k, m or g)
  --name=""                  Assign a name to the container
  --net="bridge"             Set the Network mode for the container
                               'bridge': creates a new network stack for the container on the docker bridge
                               'none': no networking for this container
                               'container:<name|id>': reuses another container network stack
                               'host': use the host network stack inside the container.  Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure.
  -P, --publish-all=false    Publish all exposed ports to random ports on the host interfaces
  -p, --publish=[]           Publish a container's port to the host
                               format: ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort | containerPort
                               (use 'docker port' to see the actual mapping)
  --pid=""                   Default is to create a private PID namespace for the container
                               'host': use the host PID namespace inside the container.  Note: the host mode gives the container full access to processes on the system and is therefore considered insecure.
  --privileged=false         Give extended privileges to this container
  --read-only=false          Mount the container's root filesystem as read only
  --restart=""               Restart policy to apply when a container exits (no, on-failure[:max-retry], always)
  --rm=false                 Automatically remove the container when it exits (incompatible with -d)
  --security-opt=[]          Security Options
  --sig-proxy=true           Proxy received signals to the process (non-TTY mode only). SIGCHLD, SIGSTOP, and SIGKILL are not proxied.
  -t, --tty=false            Allocate a pseudo-TTY
  -u, --user=""              Username or UID
  -v, --volume=[]            Bind mount a volume (e.g., from the host: -v /host:/container, from Docker: -v /container)
  --volumes-from=[]          Mount volumes from the specified container(s)
  -w, --workdir=""           Working directory inside the container

Example source options:
  --source=file://config.yml


------------------------------------------


Usage: fugu exec [LABEL] [OPTIONS] [COMMAND] [ARG...]

Run a command in a running container

Fugu options:
  --arg=[]           ARG
  --command=""       COMMAND
  --dry-run=false    Just print commands
  --name=""          Name of the container
  --source=[]        Get data from this source

Docker options:
  -d, --detach=false         Detached mode: run command in the background
  -i, --interactive=false    Keep STDIN open even if not attached
  -t, --tty=false            Allocate a pseudo-TTY

Example source options:
  --source=file://config.yml


------------------------------------------


Usage: fugu shell [LABEL] [OPTIONS]

Open a shell in a running container

Fugu options:
  --dry-run=false        Just print commands
  --name=""              Name of the container
  --shell="/bin/bash"    Path to shell
  --source=[]            Get data from this source

Example source options:
  --source=file://config.yml


------------------------------------------


Usage: fugu destroy [LABEL]

Kil a running container and remove it

Fugu options:
  --dry-run=false    Just print commands
  --name=""          Name of the container to be destroyed
  --source=[]        Get data from this source

Docker options:

Example source options:
  --source=file://config.yml


------------------------------------------


Usage: fugu push [LABEL] [OPTIONS] [TAG]

Push an image or a repository to the registry

Fugu options:
  --dry-run=false    Just print commands
  --image=""         Name of the image
  --source=[]        Get data from this source
  --tag=""           Push this tag of the image

Docker options:

Example source options:
  --source=file://config.yml


------------------------------------------


Usage: fugu pull [OPTIONS] [TAG]

Pull an image or a repository from the registry

Fugu options:
  --dry-run=false    Just print commands
  --image=""         Name of the image
  --source=[]        Get data from this source
  --tag=""           Pull this tag of the image

Docker options:
  -a, --all-tags=false    Download all tagged images in the repository

Example source options:
  --source=file://config.yml


------------------------------------------


Usage: fugu images [REGISTRY]

List images (from remote registry)

Fugu options:
  --file="~/.dockercfg"     Read credentials from this file
  --password=""             Use this password
  --password-stdin=false    Ask for password
  --registry=""             URL of the registry
  --user=""                 Use this username

Example source options:
  --source=file://config.yml


------------------------------------------


Usage: fugu show-data [LABEL] [OPTIONS]

Show aggregated data for label

Fugu options:
  --source=[]        Get data from this source

Example source options:
  --source=file://config.yml


------------------------------------------


Usage: fugu show-labels [OPTIONS]

Show all labels

Fugu options:
  --source=[]        Get data from this source

Example source options:
  --source=file://config.yml
